// FBInk is licenced under the GPL3 licence

// WARNING: This file has automatically been generated on Sun, 13 Oct 2019 21:08:31 NZDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package fbink

/*
#cgo LDFLAGS: -L${SRCDIR}/../../Release -lfbink -lm
#include "../../fbink.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocFbinkstateMemory allocates memory for type C.FBInkState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFbinkstateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFbinkstateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFbinkstateValue = unsafe.Sizeof([1]C.FBInkState{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fbinkstate) Ref() *C.FBInkState {
	if x == nil {
		return nil
	}
	return x.refab522f15
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fbinkstate) Free() {
	if x != nil && x.allocsab522f15 != nil {
		x.allocsab522f15.(*cgoAllocMap).Free()
		x.refab522f15 = nil
	}
}

// NewFbinkstateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFbinkstateRef(ref unsafe.Pointer) *Fbinkstate {
	if ref == nil {
		return nil
	}
	obj := new(Fbinkstate)
	obj.refab522f15 = (*C.FBInkState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fbinkstate) PassRef() (*C.FBInkState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refab522f15 != nil {
		return x.refab522f15, nil
	}
	memab522f15 := allocFbinkstateMemory(1)
	refab522f15 := (*C.FBInkState)(memab522f15)
	allocsab522f15 := new(cgoAllocMap)
	allocsab522f15.Add(memab522f15)

	var cuser_hz_allocs *cgoAllocMap
	refab522f15.user_hz, cuser_hz_allocs = (C.long)(x.UserHz), cgoAllocsUnknown
	allocsab522f15.Borrow(cuser_hz_allocs)

	var cfont_name_allocs *cgoAllocMap
	refab522f15.font_name, cfont_name_allocs = unpackPCharString(x.FontName)
	allocsab522f15.Borrow(cfont_name_allocs)

	var cview_width_allocs *cgoAllocMap
	refab522f15.view_width, cview_width_allocs = (C.uint32_t)(x.ViewWidth), cgoAllocsUnknown
	allocsab522f15.Borrow(cview_width_allocs)

	var cview_height_allocs *cgoAllocMap
	refab522f15.view_height, cview_height_allocs = (C.uint32_t)(x.ViewHeight), cgoAllocsUnknown
	allocsab522f15.Borrow(cview_height_allocs)

	var cscreen_width_allocs *cgoAllocMap
	refab522f15.screen_width, cscreen_width_allocs = (C.uint32_t)(x.ScreenWidth), cgoAllocsUnknown
	allocsab522f15.Borrow(cscreen_width_allocs)

	var cscreen_height_allocs *cgoAllocMap
	refab522f15.screen_height, cscreen_height_allocs = (C.uint32_t)(x.ScreenHeight), cgoAllocsUnknown
	allocsab522f15.Borrow(cscreen_height_allocs)

	var cbpp_allocs *cgoAllocMap
	refab522f15.bpp, cbpp_allocs = (C.uint32_t)(x.Bpp), cgoAllocsUnknown
	allocsab522f15.Borrow(cbpp_allocs)

	var cdevice_name_allocs *cgoAllocMap
	refab522f15.device_name, cdevice_name_allocs = *(*[16]C.char)(unsafe.Pointer(&x.DeviceName)), cgoAllocsUnknown
	allocsab522f15.Borrow(cdevice_name_allocs)

	var cdevice_codename_allocs *cgoAllocMap
	refab522f15.device_codename, cdevice_codename_allocs = *(*[16]C.char)(unsafe.Pointer(&x.DeviceCodename)), cgoAllocsUnknown
	allocsab522f15.Borrow(cdevice_codename_allocs)

	var cdevice_platform_allocs *cgoAllocMap
	refab522f15.device_platform, cdevice_platform_allocs = *(*[16]C.char)(unsafe.Pointer(&x.DevicePlatform)), cgoAllocsUnknown
	allocsab522f15.Borrow(cdevice_platform_allocs)

	var cdevice_id_allocs *cgoAllocMap
	refab522f15.device_id, cdevice_id_allocs = (C.ushort)(x.DeviceId), cgoAllocsUnknown
	allocsab522f15.Borrow(cdevice_id_allocs)

	var cpen_fg_color_allocs *cgoAllocMap
	refab522f15.pen_fg_color, cpen_fg_color_allocs = (C.uint8_t)(x.PenFgColor), cgoAllocsUnknown
	allocsab522f15.Borrow(cpen_fg_color_allocs)

	var cpen_bg_color_allocs *cgoAllocMap
	refab522f15.pen_bg_color, cpen_bg_color_allocs = (C.uint8_t)(x.PenBgColor), cgoAllocsUnknown
	allocsab522f15.Borrow(cpen_bg_color_allocs)

	var cscreen_dpi_allocs *cgoAllocMap
	refab522f15.screen_dpi, cscreen_dpi_allocs = (C.ushort)(x.ScreenDpi), cgoAllocsUnknown
	allocsab522f15.Borrow(cscreen_dpi_allocs)

	var cfont_w_allocs *cgoAllocMap
	refab522f15.font_w, cfont_w_allocs = (C.ushort)(x.FontW), cgoAllocsUnknown
	allocsab522f15.Borrow(cfont_w_allocs)

	var cfont_h_allocs *cgoAllocMap
	refab522f15.font_h, cfont_h_allocs = (C.ushort)(x.FontH), cgoAllocsUnknown
	allocsab522f15.Borrow(cfont_h_allocs)

	var cmax_cols_allocs *cgoAllocMap
	refab522f15.max_cols, cmax_cols_allocs = (C.ushort)(x.MaxCols), cgoAllocsUnknown
	allocsab522f15.Borrow(cmax_cols_allocs)

	var cmax_rows_allocs *cgoAllocMap
	refab522f15.max_rows, cmax_rows_allocs = (C.ushort)(x.MaxRows), cgoAllocsUnknown
	allocsab522f15.Borrow(cmax_rows_allocs)

	var cview_hori_origin_allocs *cgoAllocMap
	refab522f15.view_hori_origin, cview_hori_origin_allocs = (C.uint8_t)(x.ViewHoriOrigin), cgoAllocsUnknown
	allocsab522f15.Borrow(cview_hori_origin_allocs)

	var cview_vert_origin_allocs *cgoAllocMap
	refab522f15.view_vert_origin, cview_vert_origin_allocs = (C.uint8_t)(x.ViewVertOrigin), cgoAllocsUnknown
	allocsab522f15.Borrow(cview_vert_origin_allocs)

	var cview_vert_offset_allocs *cgoAllocMap
	refab522f15.view_vert_offset, cview_vert_offset_allocs = (C.uint8_t)(x.ViewVertOffset), cgoAllocsUnknown
	allocsab522f15.Borrow(cview_vert_offset_allocs)

	var cfontsize_mult_allocs *cgoAllocMap
	refab522f15.fontsize_mult, cfontsize_mult_allocs = (C.uint8_t)(x.FontsizeMult), cgoAllocsUnknown
	allocsab522f15.Borrow(cfontsize_mult_allocs)

	var cglyph_width_allocs *cgoAllocMap
	refab522f15.glyph_width, cglyph_width_allocs = (C.uint8_t)(x.GlyphWidth), cgoAllocsUnknown
	allocsab522f15.Borrow(cglyph_width_allocs)

	var cglyph_height_allocs *cgoAllocMap
	refab522f15.glyph_height, cglyph_height_allocs = (C.uint8_t)(x.GlyphHeight), cgoAllocsUnknown
	allocsab522f15.Borrow(cglyph_height_allocs)

	var cis_perfect_fit_allocs *cgoAllocMap
	refab522f15.is_perfect_fit, cis_perfect_fit_allocs = (C._Bool)(x.IsPerfectFit), cgoAllocsUnknown
	allocsab522f15.Borrow(cis_perfect_fit_allocs)

	var cis_kobo_non_mt_allocs *cgoAllocMap
	refab522f15.is_kobo_non_mt, cis_kobo_non_mt_allocs = (C._Bool)(x.IsKoboNonMt), cgoAllocsUnknown
	allocsab522f15.Borrow(cis_kobo_non_mt_allocs)

	var cntx_boot_rota_allocs *cgoAllocMap
	refab522f15.ntx_boot_rota, cntx_boot_rota_allocs = (C.uint8_t)(x.NtxBootRota), cgoAllocsUnknown
	allocsab522f15.Borrow(cntx_boot_rota_allocs)

	var cntx_rota_quirk_allocs *cgoAllocMap
	refab522f15.ntx_rota_quirk, cntx_rota_quirk_allocs = (C.uint8_t)(x.NtxRotaQuirk), cgoAllocsUnknown
	allocsab522f15.Borrow(cntx_rota_quirk_allocs)

	var cis_ntx_quirky_landscape_allocs *cgoAllocMap
	refab522f15.is_ntx_quirky_landscape, cis_ntx_quirky_landscape_allocs = (C._Bool)(x.IsNtxQuirkyLandscape), cgoAllocsUnknown
	allocsab522f15.Borrow(cis_ntx_quirky_landscape_allocs)

	var ccurrent_rota_allocs *cgoAllocMap
	refab522f15.current_rota, ccurrent_rota_allocs = (C.uint8_t)(x.CurrentRota), cgoAllocsUnknown
	allocsab522f15.Borrow(ccurrent_rota_allocs)

	var ccan_rotate_allocs *cgoAllocMap
	refab522f15.can_rotate, ccan_rotate_allocs = (C._Bool)(x.CanRotate), cgoAllocsUnknown
	allocsab522f15.Borrow(ccan_rotate_allocs)

	x.refab522f15 = refab522f15
	x.allocsab522f15 = allocsab522f15
	return refab522f15, allocsab522f15

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fbinkstate) PassValue() (C.FBInkState, *cgoAllocMap) {
	if x.refab522f15 != nil {
		return *x.refab522f15, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fbinkstate) Deref() {
	if x.refab522f15 == nil {
		return
	}
	x.UserHz = (int)(x.refab522f15.user_hz)
	x.FontName = packPCharString(x.refab522f15.font_name)
	x.ViewWidth = (uint32)(x.refab522f15.view_width)
	x.ViewHeight = (uint32)(x.refab522f15.view_height)
	x.ScreenWidth = (uint32)(x.refab522f15.screen_width)
	x.ScreenHeight = (uint32)(x.refab522f15.screen_height)
	x.Bpp = (uint32)(x.refab522f15.bpp)
	x.DeviceName = *(*[16]byte)(unsafe.Pointer(&x.refab522f15.device_name))
	x.DeviceCodename = *(*[16]byte)(unsafe.Pointer(&x.refab522f15.device_codename))
	x.DevicePlatform = *(*[16]byte)(unsafe.Pointer(&x.refab522f15.device_platform))
	x.DeviceId = (uint16)(x.refab522f15.device_id)
	x.PenFgColor = (byte)(x.refab522f15.pen_fg_color)
	x.PenBgColor = (byte)(x.refab522f15.pen_bg_color)
	x.ScreenDpi = (uint16)(x.refab522f15.screen_dpi)
	x.FontW = (uint16)(x.refab522f15.font_w)
	x.FontH = (uint16)(x.refab522f15.font_h)
	x.MaxCols = (uint16)(x.refab522f15.max_cols)
	x.MaxRows = (uint16)(x.refab522f15.max_rows)
	x.ViewHoriOrigin = (byte)(x.refab522f15.view_hori_origin)
	x.ViewVertOrigin = (byte)(x.refab522f15.view_vert_origin)
	x.ViewVertOffset = (byte)(x.refab522f15.view_vert_offset)
	x.FontsizeMult = (byte)(x.refab522f15.fontsize_mult)
	x.GlyphWidth = (byte)(x.refab522f15.glyph_width)
	x.GlyphHeight = (byte)(x.refab522f15.glyph_height)
	x.IsPerfectFit = (bool)(x.refab522f15.is_perfect_fit)
	x.IsKoboNonMt = (bool)(x.refab522f15.is_kobo_non_mt)
	x.NtxBootRota = (byte)(x.refab522f15.ntx_boot_rota)
	x.NtxRotaQuirk = (byte)(x.refab522f15.ntx_rota_quirk)
	x.IsNtxQuirkyLandscape = (bool)(x.refab522f15.is_ntx_quirky_landscape)
	x.CurrentRota = (byte)(x.refab522f15.current_rota)
	x.CanRotate = (bool)(x.refab522f15.can_rotate)
}

// allocFbinkconfigMemory allocates memory for type C.FBInkConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFbinkconfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFbinkconfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFbinkconfigValue = unsafe.Sizeof([1]C.FBInkConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fbinkconfig) Ref() *C.FBInkConfig {
	if x == nil {
		return nil
	}
	return x.ref933021fe
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fbinkconfig) Free() {
	if x != nil && x.allocs933021fe != nil {
		x.allocs933021fe.(*cgoAllocMap).Free()
		x.ref933021fe = nil
	}
}

// NewFbinkconfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFbinkconfigRef(ref unsafe.Pointer) *Fbinkconfig {
	if ref == nil {
		return nil
	}
	obj := new(Fbinkconfig)
	obj.ref933021fe = (*C.FBInkConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fbinkconfig) PassRef() (*C.FBInkConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref933021fe != nil {
		return x.ref933021fe, nil
	}
	mem933021fe := allocFbinkconfigMemory(1)
	ref933021fe := (*C.FBInkConfig)(mem933021fe)
	allocs933021fe := new(cgoAllocMap)
	allocs933021fe.Add(mem933021fe)

	var crow_allocs *cgoAllocMap
	ref933021fe.row, crow_allocs = (C.short)(x.Row), cgoAllocsUnknown
	allocs933021fe.Borrow(crow_allocs)

	var ccol_allocs *cgoAllocMap
	ref933021fe.col, ccol_allocs = (C.short)(x.Col), cgoAllocsUnknown
	allocs933021fe.Borrow(ccol_allocs)

	var cfontmult_allocs *cgoAllocMap
	ref933021fe.fontmult, cfontmult_allocs = (C.uint8_t)(x.Fontmult), cgoAllocsUnknown
	allocs933021fe.Borrow(cfontmult_allocs)

	var cfontname_allocs *cgoAllocMap
	ref933021fe.fontname, cfontname_allocs = (C.uint8_t)(x.Fontname), cgoAllocsUnknown
	allocs933021fe.Borrow(cfontname_allocs)

	var cis_inverted_allocs *cgoAllocMap
	ref933021fe.is_inverted, cis_inverted_allocs = (C._Bool)(x.IsInverted), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_inverted_allocs)

	var cis_flashing_allocs *cgoAllocMap
	ref933021fe.is_flashing, cis_flashing_allocs = (C._Bool)(x.IsFlashing), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_flashing_allocs)

	var cis_cleared_allocs *cgoAllocMap
	ref933021fe.is_cleared, cis_cleared_allocs = (C._Bool)(x.IsCleared), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_cleared_allocs)

	var cis_centered_allocs *cgoAllocMap
	ref933021fe.is_centered, cis_centered_allocs = (C._Bool)(x.IsCentered), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_centered_allocs)

	var choffset_allocs *cgoAllocMap
	ref933021fe.hoffset, choffset_allocs = (C.short)(x.Hoffset), cgoAllocsUnknown
	allocs933021fe.Borrow(choffset_allocs)

	var cvoffset_allocs *cgoAllocMap
	ref933021fe.voffset, cvoffset_allocs = (C.short)(x.Voffset), cgoAllocsUnknown
	allocs933021fe.Borrow(cvoffset_allocs)

	var cis_halfway_allocs *cgoAllocMap
	ref933021fe.is_halfway, cis_halfway_allocs = (C._Bool)(x.IsHalfway), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_halfway_allocs)

	var cis_padded_allocs *cgoAllocMap
	ref933021fe.is_padded, cis_padded_allocs = (C._Bool)(x.IsPadded), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_padded_allocs)

	var cis_rpadded_allocs *cgoAllocMap
	ref933021fe.is_rpadded, cis_rpadded_allocs = (C._Bool)(x.IsRpadded), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_rpadded_allocs)

	var cfg_color_allocs *cgoAllocMap
	ref933021fe.fg_color, cfg_color_allocs = (C.uint8_t)(x.FgColor), cgoAllocsUnknown
	allocs933021fe.Borrow(cfg_color_allocs)

	var cbg_color_allocs *cgoAllocMap
	ref933021fe.bg_color, cbg_color_allocs = (C.uint8_t)(x.BgColor), cgoAllocsUnknown
	allocs933021fe.Borrow(cbg_color_allocs)

	var cis_overlay_allocs *cgoAllocMap
	ref933021fe.is_overlay, cis_overlay_allocs = (C._Bool)(x.IsOverlay), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_overlay_allocs)

	var cis_bgless_allocs *cgoAllocMap
	ref933021fe.is_bgless, cis_bgless_allocs = (C._Bool)(x.IsBgless), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_bgless_allocs)

	var cis_fgless_allocs *cgoAllocMap
	ref933021fe.is_fgless, cis_fgless_allocs = (C._Bool)(x.IsFgless), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_fgless_allocs)

	var cno_viewport_allocs *cgoAllocMap
	ref933021fe.no_viewport, cno_viewport_allocs = (C._Bool)(x.NoViewport), cgoAllocsUnknown
	allocs933021fe.Borrow(cno_viewport_allocs)

	var cis_verbose_allocs *cgoAllocMap
	ref933021fe.is_verbose, cis_verbose_allocs = (C._Bool)(x.IsVerbose), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_verbose_allocs)

	var cis_quiet_allocs *cgoAllocMap
	ref933021fe.is_quiet, cis_quiet_allocs = (C._Bool)(x.IsQuiet), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_quiet_allocs)

	var cignore_alpha_allocs *cgoAllocMap
	ref933021fe.ignore_alpha, cignore_alpha_allocs = (C._Bool)(x.IgnoreAlpha), cgoAllocsUnknown
	allocs933021fe.Borrow(cignore_alpha_allocs)

	var chalign_allocs *cgoAllocMap
	ref933021fe.halign, chalign_allocs = (C.uint8_t)(x.Halign), cgoAllocsUnknown
	allocs933021fe.Borrow(chalign_allocs)

	var cvalign_allocs *cgoAllocMap
	ref933021fe.valign, cvalign_allocs = (C.uint8_t)(x.Valign), cgoAllocsUnknown
	allocs933021fe.Borrow(cvalign_allocs)

	var cscaled_width_allocs *cgoAllocMap
	ref933021fe.scaled_width, cscaled_width_allocs = (C.short)(x.ScaledWidth), cgoAllocsUnknown
	allocs933021fe.Borrow(cscaled_width_allocs)

	var cscaled_height_allocs *cgoAllocMap
	ref933021fe.scaled_height, cscaled_height_allocs = (C.short)(x.ScaledHeight), cgoAllocsUnknown
	allocs933021fe.Borrow(cscaled_height_allocs)

	var cwfm_mode_allocs *cgoAllocMap
	ref933021fe.wfm_mode, cwfm_mode_allocs = (C.uint8_t)(x.WfmMode), cgoAllocsUnknown
	allocs933021fe.Borrow(cwfm_mode_allocs)

	var cis_dithered_allocs *cgoAllocMap
	ref933021fe.is_dithered, cis_dithered_allocs = (C._Bool)(x.IsDithered), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_dithered_allocs)

	var csw_dithering_allocs *cgoAllocMap
	ref933021fe.sw_dithering, csw_dithering_allocs = (C._Bool)(x.SwDithering), cgoAllocsUnknown
	allocs933021fe.Borrow(csw_dithering_allocs)

	var cis_nightmode_allocs *cgoAllocMap
	ref933021fe.is_nightmode, cis_nightmode_allocs = (C._Bool)(x.IsNightmode), cgoAllocsUnknown
	allocs933021fe.Borrow(cis_nightmode_allocs)

	var cno_refresh_allocs *cgoAllocMap
	ref933021fe.no_refresh, cno_refresh_allocs = (C._Bool)(x.NoRefresh), cgoAllocsUnknown
	allocs933021fe.Borrow(cno_refresh_allocs)

	var cto_syslog_allocs *cgoAllocMap
	ref933021fe.to_syslog, cto_syslog_allocs = (C._Bool)(x.ToSyslog), cgoAllocsUnknown
	allocs933021fe.Borrow(cto_syslog_allocs)

	x.ref933021fe = ref933021fe
	x.allocs933021fe = allocs933021fe
	return ref933021fe, allocs933021fe

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fbinkconfig) PassValue() (C.FBInkConfig, *cgoAllocMap) {
	if x.ref933021fe != nil {
		return *x.ref933021fe, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fbinkconfig) Deref() {
	if x.ref933021fe == nil {
		return
	}
	x.Row = (int16)(x.ref933021fe.row)
	x.Col = (int16)(x.ref933021fe.col)
	x.Fontmult = (byte)(x.ref933021fe.fontmult)
	x.Fontname = (byte)(x.ref933021fe.fontname)
	x.IsInverted = (bool)(x.ref933021fe.is_inverted)
	x.IsFlashing = (bool)(x.ref933021fe.is_flashing)
	x.IsCleared = (bool)(x.ref933021fe.is_cleared)
	x.IsCentered = (bool)(x.ref933021fe.is_centered)
	x.Hoffset = (int16)(x.ref933021fe.hoffset)
	x.Voffset = (int16)(x.ref933021fe.voffset)
	x.IsHalfway = (bool)(x.ref933021fe.is_halfway)
	x.IsPadded = (bool)(x.ref933021fe.is_padded)
	x.IsRpadded = (bool)(x.ref933021fe.is_rpadded)
	x.FgColor = (byte)(x.ref933021fe.fg_color)
	x.BgColor = (byte)(x.ref933021fe.bg_color)
	x.IsOverlay = (bool)(x.ref933021fe.is_overlay)
	x.IsBgless = (bool)(x.ref933021fe.is_bgless)
	x.IsFgless = (bool)(x.ref933021fe.is_fgless)
	x.NoViewport = (bool)(x.ref933021fe.no_viewport)
	x.IsVerbose = (bool)(x.ref933021fe.is_verbose)
	x.IsQuiet = (bool)(x.ref933021fe.is_quiet)
	x.IgnoreAlpha = (bool)(x.ref933021fe.ignore_alpha)
	x.Halign = (byte)(x.ref933021fe.halign)
	x.Valign = (byte)(x.ref933021fe.valign)
	x.ScaledWidth = (int16)(x.ref933021fe.scaled_width)
	x.ScaledHeight = (int16)(x.ref933021fe.scaled_height)
	x.WfmMode = (byte)(x.ref933021fe.wfm_mode)
	x.IsDithered = (bool)(x.ref933021fe.is_dithered)
	x.SwDithering = (bool)(x.ref933021fe.sw_dithering)
	x.IsNightmode = (bool)(x.ref933021fe.is_nightmode)
	x.NoRefresh = (bool)(x.ref933021fe.no_refresh)
	x.ToSyslog = (bool)(x.ref933021fe.to_syslog)
}

// allocFbinkotconfigMemory allocates memory for type C.FBInkOTConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFbinkotconfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFbinkotconfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFbinkotconfigValue = unsafe.Sizeof([1]C.FBInkOTConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fbinkotconfig) Ref() *C.FBInkOTConfig {
	if x == nil {
		return nil
	}
	return x.ref379abb47
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fbinkotconfig) Free() {
	if x != nil && x.allocs379abb47 != nil {
		x.allocs379abb47.(*cgoAllocMap).Free()
		x.ref379abb47 = nil
	}
}

// NewFbinkotconfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFbinkotconfigRef(ref unsafe.Pointer) *Fbinkotconfig {
	if ref == nil {
		return nil
	}
	obj := new(Fbinkotconfig)
	obj.ref379abb47 = (*C.FBInkOTConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fbinkotconfig) PassRef() (*C.FBInkOTConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref379abb47 != nil {
		return x.ref379abb47, nil
	}
	mem379abb47 := allocFbinkotconfigMemory(1)
	ref379abb47 := (*C.FBInkOTConfig)(mem379abb47)
	allocs379abb47 := new(cgoAllocMap)
	allocs379abb47.Add(mem379abb47)

	var csize_pt_allocs *cgoAllocMap
	ref379abb47.size_pt, csize_pt_allocs = (C.float)(x.SizePt), cgoAllocsUnknown
	allocs379abb47.Borrow(csize_pt_allocs)

	var csize_px_allocs *cgoAllocMap
	ref379abb47.size_px, csize_px_allocs = (C.ushort)(x.SizePx), cgoAllocsUnknown
	allocs379abb47.Borrow(csize_px_allocs)

	var cis_centered_allocs *cgoAllocMap
	ref379abb47.is_centered, cis_centered_allocs = (C._Bool)(x.IsCentered), cgoAllocsUnknown
	allocs379abb47.Borrow(cis_centered_allocs)

	var cis_formatted_allocs *cgoAllocMap
	ref379abb47.is_formatted, cis_formatted_allocs = (C._Bool)(x.IsFormatted), cgoAllocsUnknown
	allocs379abb47.Borrow(cis_formatted_allocs)

	var ccompute_only_allocs *cgoAllocMap
	ref379abb47.compute_only, ccompute_only_allocs = (C._Bool)(x.ComputeOnly), cgoAllocsUnknown
	allocs379abb47.Borrow(ccompute_only_allocs)

	var cno_truncation_allocs *cgoAllocMap
	ref379abb47.no_truncation, cno_truncation_allocs = (C._Bool)(x.NoTruncation), cgoAllocsUnknown
	allocs379abb47.Borrow(cno_truncation_allocs)

	x.ref379abb47 = ref379abb47
	x.allocs379abb47 = allocs379abb47
	return ref379abb47, allocs379abb47

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fbinkotconfig) PassValue() (C.FBInkOTConfig, *cgoAllocMap) {
	if x.ref379abb47 != nil {
		return *x.ref379abb47, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fbinkotconfig) Deref() {
	if x.ref379abb47 == nil {
		return
	}
	x.SizePt = (float32)(x.ref379abb47.size_pt)
	x.SizePx = (uint16)(x.ref379abb47.size_px)
	x.IsCentered = (bool)(x.ref379abb47.is_centered)
	x.IsFormatted = (bool)(x.ref379abb47.is_formatted)
	x.ComputeOnly = (bool)(x.ref379abb47.compute_only)
	x.NoTruncation = (bool)(x.ref379abb47.no_truncation)
}

// allocFbinkotfitMemory allocates memory for type C.FBInkOTFit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFbinkotfitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFbinkotfitValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFbinkotfitValue = unsafe.Sizeof([1]C.FBInkOTFit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fbinkotfit) Ref() *C.FBInkOTFit {
	if x == nil {
		return nil
	}
	return x.ref6aee623
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fbinkotfit) Free() {
	if x != nil && x.allocs6aee623 != nil {
		x.allocs6aee623.(*cgoAllocMap).Free()
		x.ref6aee623 = nil
	}
}

// NewFbinkotfitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFbinkotfitRef(ref unsafe.Pointer) *Fbinkotfit {
	if ref == nil {
		return nil
	}
	obj := new(Fbinkotfit)
	obj.ref6aee623 = (*C.FBInkOTFit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fbinkotfit) PassRef() (*C.FBInkOTFit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6aee623 != nil {
		return x.ref6aee623, nil
	}
	mem6aee623 := allocFbinkotfitMemory(1)
	ref6aee623 := (*C.FBInkOTFit)(mem6aee623)
	allocs6aee623 := new(cgoAllocMap)
	allocs6aee623.Add(mem6aee623)

	var ccomputed_lines_allocs *cgoAllocMap
	ref6aee623.computed_lines, ccomputed_lines_allocs = (C.ushort)(x.ComputedLines), cgoAllocsUnknown
	allocs6aee623.Borrow(ccomputed_lines_allocs)

	var crendered_lines_allocs *cgoAllocMap
	ref6aee623.rendered_lines, crendered_lines_allocs = (C.ushort)(x.RenderedLines), cgoAllocsUnknown
	allocs6aee623.Borrow(crendered_lines_allocs)

	var ctruncated_allocs *cgoAllocMap
	ref6aee623.truncated, ctruncated_allocs = (C._Bool)(x.Truncated), cgoAllocsUnknown
	allocs6aee623.Borrow(ctruncated_allocs)

	x.ref6aee623 = ref6aee623
	x.allocs6aee623 = allocs6aee623
	return ref6aee623, allocs6aee623

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fbinkotfit) PassValue() (C.FBInkOTFit, *cgoAllocMap) {
	if x.ref6aee623 != nil {
		return *x.ref6aee623, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fbinkotfit) Deref() {
	if x.ref6aee623 == nil {
		return
	}
	x.ComputedLines = (uint16)(x.ref6aee623.computed_lines)
	x.RenderedLines = (uint16)(x.ref6aee623.rendered_lines)
	x.Truncated = (bool)(x.ref6aee623.truncated)
}

// allocFbinkrectMemory allocates memory for type C.FBInkRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFbinkrectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFbinkrectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFbinkrectValue = unsafe.Sizeof([1]C.FBInkRect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fbinkrect) Ref() *C.FBInkRect {
	if x == nil {
		return nil
	}
	return x.ref1b16f0cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fbinkrect) Free() {
	if x != nil && x.allocs1b16f0cc != nil {
		x.allocs1b16f0cc.(*cgoAllocMap).Free()
		x.ref1b16f0cc = nil
	}
}

// NewFbinkrectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFbinkrectRef(ref unsafe.Pointer) *Fbinkrect {
	if ref == nil {
		return nil
	}
	obj := new(Fbinkrect)
	obj.ref1b16f0cc = (*C.FBInkRect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fbinkrect) PassRef() (*C.FBInkRect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1b16f0cc != nil {
		return x.ref1b16f0cc, nil
	}
	mem1b16f0cc := allocFbinkrectMemory(1)
	ref1b16f0cc := (*C.FBInkRect)(mem1b16f0cc)
	allocs1b16f0cc := new(cgoAllocMap)
	allocs1b16f0cc.Add(mem1b16f0cc)

	var cleft_allocs *cgoAllocMap
	ref1b16f0cc.left, cleft_allocs = (C.ushort)(x.Left), cgoAllocsUnknown
	allocs1b16f0cc.Borrow(cleft_allocs)

	var ctop_allocs *cgoAllocMap
	ref1b16f0cc.top, ctop_allocs = (C.ushort)(x.Top), cgoAllocsUnknown
	allocs1b16f0cc.Borrow(ctop_allocs)

	var cwidth_allocs *cgoAllocMap
	ref1b16f0cc.width, cwidth_allocs = (C.ushort)(x.Width), cgoAllocsUnknown
	allocs1b16f0cc.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref1b16f0cc.height, cheight_allocs = (C.ushort)(x.Height), cgoAllocsUnknown
	allocs1b16f0cc.Borrow(cheight_allocs)

	x.ref1b16f0cc = ref1b16f0cc
	x.allocs1b16f0cc = allocs1b16f0cc
	return ref1b16f0cc, allocs1b16f0cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fbinkrect) PassValue() (C.FBInkRect, *cgoAllocMap) {
	if x.ref1b16f0cc != nil {
		return *x.ref1b16f0cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fbinkrect) Deref() {
	if x.ref1b16f0cc == nil {
		return
	}
	x.Left = (uint16)(x.ref1b16f0cc.left)
	x.Top = (uint16)(x.ref1b16f0cc.top)
	x.Width = (uint16)(x.ref1b16f0cc.width)
	x.Height = (uint16)(x.ref1b16f0cc.height)
}

// allocFbinkdumpMemory allocates memory for type C.FBInkDump in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFbinkdumpMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFbinkdumpValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFbinkdumpValue = unsafe.Sizeof([1]C.FBInkDump{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fbinkdump) Ref() *C.FBInkDump {
	if x == nil {
		return nil
	}
	return x.refebacb268
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fbinkdump) Free() {
	if x != nil && x.allocsebacb268 != nil {
		x.allocsebacb268.(*cgoAllocMap).Free()
		x.refebacb268 = nil
	}
}

// NewFbinkdumpRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFbinkdumpRef(ref unsafe.Pointer) *Fbinkdump {
	if ref == nil {
		return nil
	}
	obj := new(Fbinkdump)
	obj.refebacb268 = (*C.FBInkDump)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fbinkdump) PassRef() (*C.FBInkDump, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebacb268 != nil {
		return x.refebacb268, nil
	}
	memebacb268 := allocFbinkdumpMemory(1)
	refebacb268 := (*C.FBInkDump)(memebacb268)
	allocsebacb268 := new(cgoAllocMap)
	allocsebacb268.Add(memebacb268)

	var cdata_allocs *cgoAllocMap
	refebacb268.data, cdata_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Data)).Data)), cgoAllocsUnknown
	allocsebacb268.Borrow(cdata_allocs)

	var csize_allocs *cgoAllocMap
	refebacb268.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocsebacb268.Borrow(csize_allocs)

	var carea_allocs *cgoAllocMap
	refebacb268.area, carea_allocs = x.Area.PassValue()
	allocsebacb268.Borrow(carea_allocs)

	var cclip_allocs *cgoAllocMap
	refebacb268.clip, cclip_allocs = x.Clip.PassValue()
	allocsebacb268.Borrow(cclip_allocs)

	var crota_allocs *cgoAllocMap
	refebacb268.rota, crota_allocs = (C.uint8_t)(x.Rota), cgoAllocsUnknown
	allocsebacb268.Borrow(crota_allocs)

	var cbpp_allocs *cgoAllocMap
	refebacb268.bpp, cbpp_allocs = (C.uint8_t)(x.Bpp), cgoAllocsUnknown
	allocsebacb268.Borrow(cbpp_allocs)

	var cis_full_allocs *cgoAllocMap
	refebacb268.is_full, cis_full_allocs = (C._Bool)(x.IsFull), cgoAllocsUnknown
	allocsebacb268.Borrow(cis_full_allocs)

	x.refebacb268 = refebacb268
	x.allocsebacb268 = allocsebacb268
	return refebacb268, allocsebacb268

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fbinkdump) PassValue() (C.FBInkDump, *cgoAllocMap) {
	if x.refebacb268 != nil {
		return *x.refebacb268, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fbinkdump) Deref() {
	if x.refebacb268 == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxfc4425b.Data = unsafe.Pointer(x.refebacb268.data)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.Size = (uint)(x.refebacb268.size)
	x.Area = *NewFbinkrectRef(unsafe.Pointer(&x.refebacb268.area))
	x.Clip = *NewFbinkrectRef(unsafe.Pointer(&x.refebacb268.clip))
	x.Rota = (byte)(x.refebacb268.rota)
	x.Bpp = (byte)(x.refebacb268.bpp)
	x.IsFull = (bool)(x.refebacb268.is_full)
}
